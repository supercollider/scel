CLASS:: EmacsBuffer
summary:: Lightweight Emacs User Interface
categories:: Frontends
related:: Classes/Emacs, Classes/EmacsWidget, Classes/EmacsNumber, Classes/EmacsButton, Classes/EmacsPushButton, Classes/EmacsText, Classes/EmacsEditablefield

CLASSMETHODS::

METHOD:: new
Create a new Emacs buffer with the specified name.
If a buffer with the same name already exists, it is cleared.

ARGUMENT:: name
The name of the new buffer.
Convention has it that generated buffers (those which do not belong
to a file) should start and end with an asterisk *.

METHOD:: at
Retrieve an instance by its name.

ARGUMENT:: name
The name of the buffer.


METHOD:: killed
Calls the TELETYPE::onClose:: method when the buffer is killed.

INSTANCEMETHODS::

METHOD:: front
Switch to this buffer in Emacs, making it the current buffer.

CODE::
p = EmacsBuffer.new;
p.front;
::

METHOD:: name
Get name of buffer.

METHOD:: free
Close this buffer. Call the TELETYPE::onClose:: method.

METHOD:: onClose
A function, which is executed when the buffer is closed.
code::
p.onClose // empty on init

p.onClose = { "Bye".postln }
p.free
::

METHOD:: use

A helper method is designed to generate a preparatory link::Classes/Array:: for Emacs Lisp code, intended to be executed within an EmacsBuffer. This array can be converted into proper Emacs Lisp code by the TELETYPE::asLispExpression:: method."

code::
p.use(['widget-insert', "Inserted text"])
// [with-current-buffer, [get-buffer, *SCWindow*], [widget-insert, Inserted text]] in case p.name == "*SCWindow*"

a = p.use(['widget-insert', "Inserted text"]).asLispExpression
// (with-current-buffer (get-buffer "*SCWindow*") (widget-insert "Inserted text"))

Emacs.evalLispExpression(a)
::

METHOD:: defineKey

ARGUMENT:: keySeq
A key sequence.

ARGUMENT:: func
A function to call when that key sequence is invoked.

CODE::
// create a key action for the buffer:
p.defineKey( "hello", { "hey there".postln; } );

// type hello on the window and look at the postbuffer
p.front;

p.defineKey( "hey there", { "hello".postln; } );

// type hey there and look at the postbuffer
p.front;
::

METHOD:: keymap
A link::Classes/Dictionary:: that holds user-defined key sequences.
code::
p.keymap.postln
::


METHOD:: insert
Insert text.

ARGUMENT:: string
The text which should be inserted.

CODE::
p.newline
p.insert( "this is a really interesting text to read in the buffer" );
::

subsection:: Change position

METHOD:: newline
Insert a newline.

CODE::
p.newline;
::

METHOD:: gotoBob
Move the cursor (point in Emacs jargon) to the beginning of the buffer.

METHOD:: gotoEob
Move point to the end of the buffer.

METHOD:: goto
Move point to a specific character position.

ARGUMENT:: position
An integer.

subsection::Widgets
Emacs widgets are interactive user interface elements used in Emacs for creating dialogues, forms, and other interactive GUI elements within Emacs buffers


METHOD:: button
Creates an link::Classes/EmacsButton::.

ARGUMENT:: states
An array of state names.

ARGUMENT:: action
A function to call when the button state changes.

ARGUMENT:: prefix
Text to insert before the current state.

ARGUMENT:: suffix
Text to insert after the current state.

CODE::
p.newline
p.button( [ "on", "off", "in between" ], { |v| v.postln; } );

p.newline
// make a button with a different look:
p.button( [ "on", "off", "in between" ], { |v| v.postln; }, "******", "+++++" );
::

METHOD:: closeButton
Creates a link::Classes/EmacsPushButton:: with predefined action function, which will close this buffer.

CODE::
p.closeButton;
::

METHOD:: editableField
Creates an link::Classes/EmacsEditableField:: which can be edited inline.

ARGUMENT:: tag
The label of the field.

ARGUMENT:: value
The default content, a string.

ARGUMENT:: action
A function to call when the user submits the content by pressing enter.

CODE::
p.newline
p.editableField( "write something here", "like this?", { |v| v.postln; } );
::
